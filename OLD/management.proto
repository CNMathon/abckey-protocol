syntax = "proto3";

/**
 * Type of the mnemonic backup given/received by the device during reset/recovery.
 */
enum BackupType {
  Bip39 = 0;            // also called "Single Backup", see BIP-0039
  Slip39_Basic = 1;     // also called "Shamir Backup", see SLIP-0039
  Slip39_Advanced = 2;  // also called "Super Shamir" or "Shamir with Groups", see SLIP-0039#two-level-scheme
}

/**
 * Request: Reset device to default state and ask for device details
 * #start
 * #next Features
 */
message Initialize {
  bytes state = 1;           // assumed device state, clear session if set and different
  bool skip_passphrase = 2;  // this session should always assume empty passphrase
}

/**
 * Request: Ask for device details (no device reset)
 * #start
 * #next Features
 */
message GetFeatures {
}

/**
 * Response: Reports various information about the device
 * #end
 */
message Features {
  string vendor = 1;               // name of the manufacturer, e.g. "trezor.io"
  uint32 major_version = 2;        // major version of the firmware/bootloader, e.g. 1
  uint32 minor_version = 3;        // minor version of the firmware/bootloader, e.g. 0
  uint32 patch_version = 4;        // patch version of the firmware/bootloader, e.g. 0
  bool bootloader_mode = 5;        // is device in bootloader mode?
  string device_id = 6;            // device's unique identifier
  bool pin_protection = 7;         // is device protected by PIN?
  bool passphrase_protection = 8;  // is node/mnemonic encrypted using passphrase?
  string language = 9;             // device language
  string label = 10;               // device description label
  bool initialized = 12;           // does device contain seed?
  bytes revision = 13;             // SCM revision of firmware
  bytes bootloader_hash = 14;      // hash of the bootloader
  bool imported = 15;              // was storage imported from an external source?
  bool pin_cached = 16;            // is PIN already cached in session?
  bool passphrase_cached = 17;     // is passphrase already cached in session?
  bool firmware_present = 18;      // is valid firmware loaded?
  bool needs_backup = 19;          // does storage need backup? (equals to Storage.needs_backup)
  uint32 flags = 20;               // device flags (equals to Storage.flags)
  string model = 21;               // device hardware model
  uint32 fw_major = 22;            // reported firmware version if in bootloader mode
  uint32 fw_minor = 23;            // reported firmware version if in bootloader mode
  uint32 fw_patch = 24;            // reported firmware version if in bootloader mode
  string fw_vendor = 25;           // reported firmware vendor if in bootloader mode
  bytes fw_vendor_keys = 26;       // reported firmware vendor keys (their hash)
  bool unfinished_backup = 27;     // report unfinished backup (equals to Storage.unfinished_backup)
  bool no_backup = 28;             // report no backup (equals to Storage.no_backup)
  bool recovery_mode = 29;         // is recovery mode in progress
  Capability capabilities = 30;    // list of supported capabilities
  enum Capability {
    Capability_Bitcoin = 1;
    Capability_Bitcoin_like = 2;  // Altcoins based on the Bitcoin source code
    Capability_Binance = 3;
    Capability_Cardano = 4;
    Capability_Crypto = 5;  // generic crypto operations for GPG, SSH, etc.
    Capability_EOS = 6;
    Capability_Ethereum = 7;
    Capability_Lisk = 8;
    Capability_Monero = 9;
    Capability_NEM = 10;
    Capability_Ripple = 11;
    Capability_Stellar = 12;
    Capability_Tezos = 13;
    Capability_U2F = 14;
    Capability_Shamir = 15;
    Capability_ShamirGroups = 16;
  }
  BackupType backup_type = 31;  // type of device backup (BIP-39 / SLIP-39 basic / SLIP-39 advanced)
  bool sd_card_present = 32;    // is SD card present
  bool sd_protection = 33;      // is SD Protect enabled
}

/**
 * Request: clear session (removes cached PIN, passphrase, etc).
 * #start
 * #next Success
 */
message ClearSession {
}

/**
 * Request: change language and/or label of the device
 * #start
 * #next Success
 * #next Failure
 */
message ApplySettings {
  string language = 1;
  string label = 2;
  bool use_passphrase = 3;
  bytes homescreen = 4;
  PassphraseSourceType passphrase_source = 5;
  uint32 auto_lock_delay_ms = 6;
  uint32 display_rotation = 7;  // in degrees from North
  /**
    * Structure representing passphrase source
    */
  enum PassphraseSourceType {
    ASK = 0;
    DEVICE = 1;
    HOST = 2;
  }
}

/**
 * Request: set flags of the device
 * #start
 * #next Success
 * #next Failure
 */
message ApplyFlags {
  uint32 flags = 1;  // bitmask, can only set bits, not unset
}

/**
 * Request: Starts workflow for setting/changing/removing the PIN
 * #start
 * #next Success
 * #next Failure
 */
message ChangePin {
  bool remove = 1;  // is PIN removal requested?
}

/**
 * Request: Starts workflow for enabling/regenerating/disabling SD card protection
 * #start
 * #next Success
 * #next Failure
 */
message SdProtect {
  SdProtectOperationType operation = 1;
  /**
    * Structure representing SD card protection operation
    */
  enum SdProtectOperationType {
    DISABLE = 0;
    ENABLE = 1;
    REFRESH = 2;
  }
}

/**
 * Request: Test if the device is alive, device sends back the message in Success response
 * #start
 * #next Success
 */
message Ping {
  string message = 1;              // message to send back in Success message
  bool button_protection = 2;      // ask for button press
  bool pin_protection = 3;         // ask for PIN if set in device
  bool passphrase_protection = 4;  // ask for passphrase if set in device
}

/**
 * Request: Abort last operation that required user interaction
 * #start
 * #next Failure
 */
message Cancel {
}

/**
 * Request: Request a sample of random data generated by hardware RNG. May be used for testing.
 * #start
 * #next Entropy
 * #next Failure
 */
message GetEntropy {
  required uint32 size = 1;  // size of requested entropy
}

/**
 * Response: Reply with random data generated by internal RNG
 * #end
 */
message Entropy {
  required bytes entropy = 1;  // chunk of random generated bytes
}

/**
 * Request: Request device to wipe all sensitive data and settings
 * #start
 * #next Success
 * #next Failure
 */
message WipeDevice {
}

/**
 * Request: Load seed and related internal settings from the computer
 * #start
 * #next Success
 * #next Failure
 */
message LoadDevice {
  string mnemonics = 1;                       // seed encoded as mnemonic (12, 18 or 24 words for BIP39, 20 or 33 for SLIP39)
  string pin = 3;                             // set PIN protection
  bool passphrase_protection = 4;             // enable master node encryption using passphrase
  string language = 5 [default = 'english'];  // device language
  string label = 6;                           // device label
  bool skip_checksum = 7;                     // do not test mnemonic for valid BIP-39 checksum
  uint32 u2f_counter = 8;                     // U2F counter
  bool needs_backup = 9;                      // set "needs backup" flag
  bool no_backup = 10;                        // indicate that no backup is going to be made
}

/**
 * Request: Ask device to do initialization involving user interaction
 * #start
 * #next EntropyRequest
 * #next Failure
 */
message ResetDevice {
  bool display_random = 1;                        // display entropy generated by the device before asking for additional entropy
  uint32 strength = 2 [default = 256];            // strength of seed in bits
  bool passphrase_protection = 3;                 // enable master node encryption using passphrase
  bool pin_protection = 4;                        // enable PIN protection
  string language = 5 [default = 'english'];      // device language
  string label = 6;                               // device label
  uint32 u2f_counter = 7;                         // U2F counter
  bool skip_backup = 8;                           // postpone seed backup to BackupDevice workflow
  bool no_backup = 9;                             // indicate that no backup is going to be made
  BackupType backup_type = 10 [default = Bip39];  // type of the mnemonic backup
}

/**
 * Request: Perform backup of the device seed if not backed up using ResetDevice
 * #start
 * #next Success
 */
message BackupDevice {
}

/**
 * Response: Ask for additional entropy from host computer
 * #next EntropyAck
 */
message EntropyRequest {
}

/**
 * Request: Provide additional entropy for seed generation function
 * #next Success
 */
message EntropyAck {
  bytes entropy = 1;  // 256 bits (32 bytes) of random data
}

/**
 * Request: Start recovery workflow asking user for specific words of mnemonic
 * Used to recovery device safely even on untrusted computer.
 * #start
 * #next WordRequest
 */
message RecoveryDevice {
  uint32 word_count = 1;                      // number of words in BIP-39 mnemonic
  bool passphrase_protection = 2;             // enable master node encryption using passphrase
  bool pin_protection = 3;                    // enable PIN protection
  string language = 4 [default = 'english'];  // device language
  string label = 5;                           // device label
  bool enforce_wordlist = 6;                  // enforce BIP-39 wordlist during the process
                                              // 7 reserved for unused recovery method
  RecoveryDeviceType type = 8;                // supported recovery type
  uint32 u2f_counter = 9;                     // U2F counter
  bool dry_run = 10;                          // perform dry-run recovery workflow (for safe mnemonic validation)
  /**
     * Type of recovery procedure. These should be used as bitmask, e.g.,
     * `RecoveryDeviceType_ScrambledWords | RecoveryDeviceType_Matrix`
     * listing every method supported by the host computer.
     *
     * Note that ScrambledWords must be supported by every implementation
     * for backward compatibility; there is no way to not support it.
     */
  enum RecoveryDeviceType {
    // use powers of two when extending this field
    RecoveryDeviceType_ScrambledWords = 0;  // words in scrambled order
    RecoveryDeviceType_Matrix = 1;          // matrix recovery type
  }
}

/**
 * Response: Device is waiting for user to enter word of the mnemonic
 * Its position is shown only on device's internal display.
 * #next WordAck
 */
message WordRequest {
  WordRequestType type = 1;
  /**
    * Type of Recovery Word request
    */
  enum WordRequestType {
    WordRequestType_Plain = 0;
    WordRequestType_Matrix9 = 1;
    WordRequestType_Matrix6 = 2;
  }
}

/**
 * Request: Computer replies with word from the mnemonic
 * #next WordRequest
 * #next Success
 * #next Failure
 */
message WordAck {
  required string word = 1;  // one word of mnemonic on asked position
}

/**
 * Request: Set U2F counter
 * #start
 * #next Success
 */
message SetU2FCounter {
  uint32 u2f_counter = 1;
}

/**
 * Request: Set U2F counter
 * #start
 * #next NextU2FCounter
 */
message GetNextU2FCounter {
}

/**
 * Request: Set U2F counter
 * #end
 */
message NextU2FCounter {
  uint32 u2f_counter = 1;
}